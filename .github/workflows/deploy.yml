name: CI/CD - Build, Push, Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy to production (default: latest)"
        required: false
        default: "latest"
      app_path:
        description: "Relative path to Maven project root (default: .)"
        required: false
        default: "."

env:
  APP_PATH: .
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECS_CLUSTER_NAME: ${{ secrets.ECS_CLUSTER_NAME }}
  ECS_SERVICE_NAME: ${{ secrets.ECS_SERVICE_NAME }}

jobs:
  test:
    name: Unit tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set app path from dispatch input (if provided)
        if: github.event_name == 'workflow_dispatch'
        run: echo "APP_PATH=${{ github.event.inputs.app_path }}" >> $GITHUB_ENV

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: 'maven'

      - name: Run tests
        working-directory: ${{ env.APP_PATH }}
        run: mvn -B -DskipTests=false test

      - name: Package (build jar)
        working-directory: ${{ env.APP_PATH }}
        run: mvn -B -DskipTests package

  build_and_push:
    name: Build and push Docker image to ECR (dev)
    runs-on: ubuntu-latest
    needs: [test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Define image URI
        id: vars
        run: |
          IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Build Docker image (multi-stage)
        run: |
          docker build \
            -f devops-technical-challenge/app/hello-world/Dockerfile \
            -t ${{ steps.vars.outputs.IMAGE_URI }}:${{ github.sha }} \
            ${{ env.APP_PATH }}

      - name: Tag latest
        run: docker tag ${{ steps.vars.outputs.IMAGE_URI }}:${{ github.sha }} ${{ steps.vars.outputs.IMAGE_URI }}:latest

      - name: Push images
        run: |
          docker push ${{ steps.vars.outputs.IMAGE_URI }}:${{ github.sha }}
          docker push ${{ steps.vars.outputs.IMAGE_URI }}:latest

  deploy_dev:
    name: Deploy to ECS (dev)
    runs-on: ubuntu-latest
    needs: [build_and_push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Define image URI
        id: vars
        run: |
          IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Get current task definition ARN
        id: current_td
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${ECS_CLUSTER_NAME}" \
            --services "${ECS_SERVICE_NAME}" \
            --query 'services[0].taskDefinition' --output text)
          echo "TD_ARN=$TD_ARN" >> $GITHUB_OUTPUT

      - name: Build new task definition with updated image
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ steps.current_td.outputs.TD_ARN }}" \
            --include TAGS \
            | jq '{
                family: .taskDefinition.family,
                taskRoleArn: .taskDefinition.taskRoleArn,
                executionRoleArn: .taskDefinition.executionRoleArn,
                networkMode: .taskDefinition.networkMode,
                containerDefinitions: (.taskDefinition.containerDefinitions | map(.image = "'${{ steps.vars.outputs.IMAGE_URI }}':'${{ github.sha }}'")),
                volumes: .taskDefinition.volumes,
                placementConstraints: .taskDefinition.placementConstraints,
                requiresCompatibilities: .taskDefinition.requiresCompatibilities,
                cpu: .taskDefinition.cpu,
                memory: .taskDefinition.memory,
                runtimePlatform: .taskDefinition.runtimePlatform,
                ephemeralStorage: .taskDefinition.ephemeralStorage
              }' > td.json
          cat td.json

      - name: Register new task definition
        id: register
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://td.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS service to use new task definition
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER_NAME}" \
            --service "${ECS_SERVICE_NAME}" \
            --task-definition "${{ steps.register.outputs.NEW_TD_ARN }}" \
            --force-new-deployment

      - name: Wait for service to reach steady state
        run: aws ecs wait services-stable --cluster "${ECS_CLUSTER_NAME}" --services "${ECS_SERVICE_NAME}"

      - name: Verify deployment
        run: |
          aws ecs describe-services \
            --cluster "${ECS_CLUSTER_NAME}" \
            --services "${ECS_SERVICE_NAME}" \
            --query 'services[0].{status: status, runningCount: runningCount, desiredCount: desiredCount, deployments: deployments}'

  deploy_prod:
    name: Deploy to ECS (production)
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: production
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Define image URI
        id: vars
        run: |
          IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Resolve image tag
        id: tag
        run: echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT

      - name: Get current task definition ARN
        id: current_td
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${ECS_CLUSTER_NAME}" \
            --services "${ECS_SERVICE_NAME}" \
            --query 'services[0].taskDefinition' --output text)
          echo "TD_ARN=$TD_ARN" >> $GITHUB_OUTPUT

      - name: Build new task definition with updated image
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ steps.current_td.outputs.TD_ARN }}" \
            --include TAGS \
            | jq '{
                family: .taskDefinition.family,
                taskRoleArn: .taskDefinition.taskRoleArn,
                executionRoleArn: .taskDefinition.executionRoleArn,
                networkMode: .taskDefinition.networkMode,
                containerDefinitions: (.taskDefinition.containerDefinitions | map(.image = "'${{ steps.vars.outputs.IMAGE_URI }}':'${{ steps.tag.outputs.IMAGE_TAG }}'")),
                volumes: .taskDefinition.volumes,
                placementConstraints: .taskDefinition.placementConstraints,
                requiresCompatibilities: .taskDefinition.requiresCompatibilities,
                cpu: .taskDefinition.cpu,
                memory: .taskDefinition.memory,
                runtimePlatform: .taskDefinition.runtimePlatform,
                ephemeralStorage: .taskDefinition.ephemeralStorage
              }' > td.json
          cat td.json

      - name: Register new task definition
        id: register
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://td.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS service to use new task definition
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER_NAME}" \
            --service "${ECS_SERVICE_NAME}" \
            --task-definition "${{ steps.register.outputs.NEW_TD_ARN }}" \
            --force-new-deployment

      - name: Wait for service to reach steady state
        run: aws ecs wait services-stable --cluster "${ECS_CLUSTER_NAME}" --services "${ECS_SERVICE_NAME}"

      - name: Verify deployment
        run: |
          aws ecs describe-services \
            --cluster "${ECS_CLUSTER_NAME}" \
            --services "${ECS_SERVICE_NAME}" \
            --query 'services[0].{status: status, runningCount: runningCount, desiredCount: desiredCount, deployments: deployments}'

  notify_failure:
    name: Failure notification
    runs-on: ubuntu-latest
    needs: [test]
    if: failure()
    steps:
      - name: Notify via Slack (optional)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          payload='{"text":"CI/CD failure on '${{ github.workflow }}' for '${{ github.ref }}' (run: '${{ github.run_id }}')."}'
          curl -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL"

      - name: Annotate failure
        run: |
          echo "::error::CI/CD failed for ${{ github.ref }} (run: ${{ github.run_id }})"
